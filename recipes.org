#+property: header-args :tangle yes
* ggplotnim recipes

This document contains recipes to create specific kinds of plots. It's
aimed mainly at people who are new the grammar of graphics. It can
also be seen as the equivalent of a plot gallery.

Note that this Org file is actually a "literate programming
document", which uses [[https://github.com/OrgTangle/ntangle][ntangle]]. If you want to generate the recipes
locally, just run:
#+BEGIN_SRC sh :tangle no
ntangle recipes.org
#+END_SRC
Note that the [[https://github.com/Vindaar/ggplotnim/tree/master/recipes][recipes]] directory of the repo already contains these files.

The document contains two kinds of recipes. 
1. First the "Get To The Point" (GTTP) kind of recipe. This is a
   minimal example to produce a specific plot, without any fancy
   options, interesting data etc.
2. And secondly the "Tell Me A Story" (TMAS) recipes, which try to
   explain every important step, typically introduce some interesting
   data set which we'll investigate to finally produce a plot of a
   certain kind. Here also alternative ways might be presented. For
   some people maybe the more interesting read. :)

** GTTP "Get To The Point" recipes

The recipes in this section present the simplest way to achieve the
desired plot, without any superfluous talking or complicating
examples. 

*** Simple line plot

Just a line plot of some data. Simple as that.

Some basic imports:
#+BEGIN_SRC nim :tangle recipes/rSimpleLinePlot.nim
import ggplotnim, sequtils, seqmath
#+END_SRC
Create some data so that we have something to plot:
#+BEGIN_SRC nim :tangle recipes/rSimpleLinePlot.nim
let x = linspace(0.0, 30.0, 1000)
let y = x.mapIt(pow(sin(it), 2.0))
#+END_SRC
Build a dataframe from it:
#+BEGIN_SRC nim :tangle recipes/rSimpleLinePlot.nim
let df = seqsToDf(x, y)
#+END_SRC
and create the plot:
#+BEGIN_SRC nim :tangle recipes/rSimpleLinePlot.nim
ggplot(df, aes("x", "y")) + # x and y are the identifiers given above as strings
  geom_line() +
  ggsave("media/recipes/rSimpleLinePlot.png")
#+END_SRC
This results in the following plot:
[[./media/recipes/rSimpleLinePlot.png]]

*** (Line) plot of specific size, different filetype

Creating a plot with a specific output size and saving it as a
different filetype is very easy. It's basically exactly the same as
the plot above with the only change in the =ggsave= call:
#+BEGIN_SRC nim :tangle recipes/rLinePlotSize.nim
import ggplotnim, sequtils, seqmath
const
  width = 720
  height = 480
let x = linspace(0.0, 30.0, 1000)
let y = x.mapIt(pow(sin(it), 2.0))
let df = seqsToDf(x, y)
ggplot(df, aes("x", "y")) +
  geom_line() +
  ggsave("media/recipes/rLinePlotSize.png", width = width, height = height)
#+END_SRC
You can see that =ggsave= accepts a =width= and =height= argument. The
desired output filetype is deduced from the filename
extension. Supported are:
- =.pdf=
- =.svg=
- =.png=
The above generates the following plot:
[[./media/recipes/rLinePlotSize.png]]

*** Stacked histogram colored by some class

Often one has a certain type of data for several discrete different
classes. In these cases a stacked histogram may be useful. Considering
the =mpg= dataset, this is done via:
#+BEGIN_SRC nim :tangle recipes/rStackedMpgHistogram.nim
import ggplotnim
let df = toDf(readCsv("data/mpg.csv"))
ggplot(df, aes("cty", fill = "class")) + 
  geom_histogram() + 
  ggsave("media/recipes/rStackedMpgHistogram.png")
#+END_SRC
This generates:

[[./media/recipes/rStackedMpgHistogram.png]]

*** Stacked lines colored by some class

*NOTE*: the first lines should actually go to 0 again. That's a bug currently.

The same as above can also be represented with lines using =geom_freqpoly=:
#+BEGIN_SRC nim :tangle recipes/rStackedMpgFreqpoly.nim
import ggplotnim
let df = toDf(readCsv("data/mpg.csv"))
ggplot(df, aes("cty", color = "class")) + 
  geom_freqpoly() + 
  ggsave("media/recipes/rStackedMpgFreqpoly.png")
#+END_SRC
This generates:

[[./media/recipes/rStackedMpgFreqpoly.png]]

*** Change alpha of the fill color

Most geoms (those which allow a =fillColor= argument / being
classified by =fill=) also allow an =alpha= field since version
=v0.2.17=.

This allows to change the alpha of the fill without affecting the
actual color or the normal =color= field.

For instance we can use it to make the above plot a little more
pretty:
#+BEGIN_SRC nim :tangle recipes/rFreqPolyWithAlpha.nim
import ggplotnim
let df = toDf(readCsv("data/mpg.csv"))
ggplot(df, aes("cty", fill = "class")) + 
  geom_freqpoly(alpha = some(0.3)) + 
  ggsave("media/recipes/rFreqPolyWithAlpha.png")
#+END_SRC
Notice how if a fill color is set, the lines are always drawn down to
0! For instance =subcompact= and =pickup= reach down to the x axis.

This generates:

[[./media/recipes/rFreqPolyWithAlpha.png]]

#+END_SRC

*** Simple histogram with N bins

Given a continuous data column we may want to calculate a histogram
with N bins:
#+BEGIN_SRC nim :tangle recipes/rMpgHistoNumBins.nim
import ggplotnim
let df = toDf(readCsv("data/mpg.csv"))
ggplot(df, aes("hwy")) + 
  geom_histogram(bins = 20) + # by default 30 bins are used
  ggsave("media/recipes/rMpgHistoNumBins.png")
#+END_SRC
This generates:

[[./media/recipes/rMpgHistoNumBins.png]]

*** Simple histogram with specific bin width

We can also set a specific bin width instead of a number of
bins. E.g. we want to bin by 1.5 mpg, which can be done using the
=binWidth= argument:
#+BEGIN_SRC nim :tangle recipes/rMpgHistoBinWidth.nim
import ggplotnim
let df = toDf(readCsv("data/mpg.csv"))
ggplot(df, aes("hwy")) + 
  geom_histogram(binWidth = 1.5) +
  ggsave("media/recipes/rMpgHistoBinWidth.png")
#+END_SRC
This generates:

[[./media/recipes/rMpgHistoBinWidth.png]]

*** Histogram with specific bin edges

Or sometimes one has specific edges in mind one wants to
investigate. This can be done via the =breaks= argument. NOTE: the
breaks given are interpreted as left bin edges plus the right most
edge of the last bin! So the below starts at 0 on the left side and
the last bin ends at 40 on the right side.
#+BEGIN_SRC nim :tangle recipes/rMpgHistoCustomBreaks.nim
import ggplotnim
let df = toDf(readCsv("data/mpg.csv"))
ggplot(df, aes("hwy")) + 
  geom_histogram(breaks = @[0'f64, 10, 15, 19, 23, 25, 40]) +
  ggsave("media/recipes/rMpgHistoCustomBreaks.png")
#+END_SRC
This generates:

[[./media/recipes/rMpgHistoCustomBreaks.png]]

*** Bin with =geom_point= and overlay on histogram with specific bin edges

While this is a bad example, there are use cases when aside from the
bins for the histogram points should be used to indicate some data
that is binned in the same way. For instance when comparing
simulations with experimental data in particle physics. In this case
here we'll just bin the point data in the same way as the histogram
itself and draw the points into the center bin positions.
#+BEGIN_SRC nim :tangle recipes/rMpgHistoPlusPoints.nim
import ggplotnim
let df = toDf(readCsv("data/mpg.csv"))
let breaks = @[0'f64, 10, 15, 19, 23, 25, 40]
ggplot(df, aes("cty")) +
  geom_histogram(breaks = breaks) +
  geom_point(stat="bin", breaks = breaks, binPosition = "center") +
  ggsave("media/recipes/rMpgHistoPlusPoints.png")
#+END_SRC
Note both additional arguments to the =geom_point= call. The
~stat="bin"~ tells ggplotnim that the user wants to perform binning of
the given x columns ("cty"). With that setting the =breaks= argument
won't be ignored and will be applied in the same way as for the
=geom_histogram= call. Finally the ~binPosition="center"~ is used to
draw the points not where the binning data is located (read: left bin
edge), but rather in the center of the bins.

This generates:

[[./media/recipes/rMpgHistoPlusPoints.png]]

*** Scatter plot with different point color

Sometimes the black points (or color of some other non classified
geom) might be boring. That's why the =geom_*= procs also take a
=color= argument. This just takes a =chroma.Color= object. Let's color
our points monokai pink:
#+BEGIN_SRC nim :tangle recipes/rMpgCustomColorPoint.nim
import ggplotnim
let df = toDf(readCsv("data/mpg.csv"))
let breaks = @[0'f64, 10, 15, 19, 23, 25, 40]
ggplot(df, aes("displ", "cty")) +
  geom_point(color = some(parseHex("F92672"))) +
  ggsave("media/recipes/rMpgCustomColorPoint.png")
#+END_SRC
Gives:

[[./media/recipes/rMpgCustomColorPoint.png]]

*** Histogram from already binned data

When dealing with histograms it's quite likely that the user has
already computed the bin content with a custom binning before hand and
simply wants to plot that information. This can also be done easily by
building a DF from that prebinned data and using ~stat="identity"~ as
the histogram argument:
#+BEGIN_SRC nim :tangle recipes/rPrebinnedHisto.nim
import ggplotnim
let bins = @[0, 2, 5, 9, 15]
let counts = @[0.1, 0.8, 0.3, 0.05, 0.0] # <- last element is dummy
let df = seqsToDf({"bin_edges" : bins, "counts" : counts})
ggplot(df, aes("bin_edges", "counts")) + 
  geom_histogram(stat = "identity") +
  ggsave("media/recipes/rPrebinnedHisto.png")
#+END_SRC
There are a couple of important things to mention here. In the case
above the user hands =x= as the bin edges (!) starting from the left
bin edge of the first bin to the right edge of the last bin. However,
this means we only have =N - 1= actual bins. Yet the DF requires all
columns to have the same number of entries (Note: technically that's
not true, it'll be filled up with =VNull= values, yet it's not a nice
solution and will cause other issues). 

There are several ways to deal with this. Either one hands one
additional dummy value in the =counts= sequence, which will be ignored
for the bin content. Alternatively, one may only hand essentially the
left edges of the bins (and thus as many =bins= elements as real
=counts= values) and let ggplotnim determine the bin width. This works
fine as long as the bin width of the second to last bin is the same as
the bin width of the last bin. So if that is the case for your data,
feel free to only hand =N - 1= elements. 

Which generates the following:

[[./media/recipes/rPrebinnedHisto.png]]

*** Simple bar plot for N categories

Often one deals with categorical data with N classes, e.g. the
different type of cars listed in the =mpg= dataset and wishes to count
the number of elements in each class. For this we can use a =geom_bar=
plot. NOTE: For the moment the only function supported is the number
of counts. =FormulaNode= and other Nim function support will probably
be added at some point (or when desired by someone):
#+BEGIN_SRC nim :tangle recipes/rMpgSimpleBarPlot.nim
import ggplotnim
let df = toDf(readCsv("data/mpg.csv"))
ggplot(df, aes("class")) + 
  geom_bar() + 
  ggsave("media/recipes/rMpgSimpleBarPlot.png")
#+END_SRC
Giving us the following result:

[[./media/recipes/rMpgSimpleBarPlot.png]]

*** Bar plot with already computed statistics, manually set scale as discrete

Consider a case in which we have a datafile for N sensors, where each
row corresponds to one measurement per minute. In that case we might
want to plot the mean value measured for all channels in a bar
plot. To achieve this, we can do the following. 

We start by putting the table into long form and parsing the channel
numbers to integers. Then we compute the mean by grouping by channel
and finally we create the plot.

Note: Parsing the channel numbers and thus having to set the x scale
as `dcDiscrete` is of course not required. But this way we combine two
examples into one. :)

#+BEGIN_SRC nim :tangle recipes/rBarPlotCompStats.nim
import ggplotnim, sequtils, seqmath, strutils
let cols = toSeq(0 .. 7).mapIt($it)
# make `parseInt` work on Values, so we can parse the long form 
# `Channel` column
#liftScalarStringProc(parseInt)
let df = toDf(readCsv("data/szinti_channel_counts.txt", 
                      sep = '\t',
                      colNames = cols))
  .gather(cols, key = "Channel", value = "Count")
  .mutate(f{string -> int: "Channel" ~ parseInt( c"Channel" )})
let dfMean = df.group_by("Channel").summarize(f{float: "Mean counts / min" << mean( c"Count" )})
# calculate mean for each channel
ggplot(dfMean, aes("Channel", "Mean counts / min")) +
  geom_bar(stat = "identity", position = "identity") +
  scale_x_continuous(name = "Channel number", dcKind = dcDiscrete) +
  ggtitle("Mean counts per channel") +
  ggsave("media/recipes/rBarPlotCompStats.png")
#+END_SRC

Gives the following plot:

[[./media/recipes/rBarPlotCompStats.png]]


*** Stacked bar plot for N categories split by some other category

Sometimes the above classes may be part of some other class though,
which is supposed to be split by as well. For instance whether cars of
a specific class are 4WD, RWD or FWD:
#+BEGIN_SRC nim :tangle recipes/rMpgStackedBarPlot.nim
import ggplotnim
let df = toDf(readCsv("data/mpg.csv"))
ggplot(df, aes("class", fill = "drv")) + 
  geom_bar() + 
  ggsave("media/recipes/rMpgStackedBarPlot.png")
#+END_SRC
Results in:

[[./media/recipes/rMpgStackedBarPlot.png]]

*** Points colored by some continuous scale

Sometimes a scatter plot is supposed to highlight some continuous
value of the points. For instance we can color a =geom_point= plot of
the =mpg= displacement versus the highway efficiency by the city
efficiency to get an even fuller picture:
#+BEGIN_SRC nim :tangle recipes/rMpgContinuousColorPoints.nim
import ggplotnim
let df = toDf(readCsv("data/mpg.csv"))
ggplot(df, aes("displ", "hwy", color = "cty")) + 
  geom_point() + 
  ggsave("media/recipes/rMpgContinuousColorPoints.png")
#+END_SRC
See:

[[./media/recipes/rMpgContinuousColorPoints.png]]

*** Using points and lines to show discrete counts

Instead of using bars to show some count data classified by two
columns, we can show the same thing using points instead. The same
plot as above is then:
#+BEGIN_SRC nim :tangle recipes/rMpgStackedPointPlot.nim
import ggplotnim
let df = toDf(readCsv("data/mpg.csv"))
ggplot(df, aes("class", color = "drv")) + 
  geom_point(stat = "count") + 
  geom_line(stat = "count") + 
  ggsave("media/recipes/rMpgStackedPointPlot.png")
#+END_SRC
Results in:

[[./media/recipes/rMpgStackedPointPlot.png]]

*** Using a discrete X scale with points

It's also just possible to draw a point (or line, see below) with an x
axis that contains discrete data while providing a continuous y axis.

#+BEGIN_SRC nim :tangle recipes/rMpgDiscreteXScale.nim
import ggplotnim
let df = toDf(readCsv("data/mpg.csv"))
# coloring by class is of course not required to make this work :)
ggplot(df, aes("cyl", "hwy", color = "class")) + 
  geom_point() + 
  ggsave("media/recipes/rMpgDiscreteXScale.png")
#+END_SRC
Results in:

[[./media/recipes/rMpgDiscreteXScale.png]]

*** Using a discrete y axis

#+BEGIN_SRC nim :tangle recipes/rDiscreteYAxis.nim
import ggplotnim
let df = toDf(readCsv("data/mpg.csv"))
ggplot(df, aes("hwy", "cyl")) +
  geom_point() +
  ggsave("media/recipes/rDiscreteYAxis.png")
#+END_SRC

[[media/recipes/rDiscreteYAxis.png]]

*** Both axes discrete

#+BEGIN_SRC nim :tangle recipes/rBothDiscreteAxes.nim
import ggplotnim
let df = toDf(readCsv("data/mpg.csv"))
ggplot(df, aes("class", "cyl", color = "class")) +
  geom_point() +
  ggsave("media/recipes/rBothDiscreteAxes.png")
#+END_SRC

[[media/recipes/rBothDiscreteAxes.png]]

*** Using a discrete X scale with lines

Inspired by https://github.com/Vindaar/ggplotnim/issues/40. 

A plot with a discrete X scale (using string values) and continuous y
scale.

#+BEGIN_SRC nim :tangle recipes/rDiscreteXLine.nim
import ggplotnim, seqmath
import random

const paths = 10
const dates = 80

proc gaussian*(rnd: var Rand, mu = 0.0, sigma = 1.0): float =
  var
    s = 0.0
    u = 0.0
    v = 0.0
  while s >= 1.0 or s <= 0.0:
    u = 2.0 * rnd.rand(0.0..1.0) - 1.0
    v = 2.0 * rnd.rand(0.0..1.0) - 1.0
    s = (u * u) + (v * v)

  let x = u * sqrt(-2.0 * ln(s) / s)
  return (mu + (sigma * x))

proc createDataFrame(): DataFrame = 
  const sigma = 0.10
  var rnd = initRand(124325)
  var pathNames = newSeq[string](dates * paths)
  var pathVals = newSeq[float](dates * paths)
  var tenors = newSeq[int](dates * paths)
  for j in 0 ..< paths:
    pathVals[j * dates] = 100.0
    pathNames[j * dates] = "path" & $(j + 1)
    tenors[j * dates] = 0
    for i in 1 ..< dates:
      let idx = j * dates + i
      pathNames[idx] = "path" & $(j + 1)
      pathVals[idx] = (pathVals[idx - 1] * exp(-0.5 * sigma * sigma + sigma * gaussian(rnd)))
      tenors[idx] = i
  result = seqsToDf({ "tenors" : tenors,
                      "pathNames" : pathNames,
                      "pathValues" : pathVals })

let df = createDataFrame()
ggplot(df, aes("tenors", "pathValues", color = "pathNames")) + 
  geom_line() +
  ggsave("media/recipes/rDiscreteXLine.png")
#+END_SRC
Results in:

[[./media/recipes/rDiscreteXLine.png]]

*** Plotting column Y1 and Y2 against X

In many practical cases we may end up with some data =Y1= and =Y2=,
which both is equivalent in the phase space sense and was measured
against the same variable but is available only in the format of:
#+BEGIN_SRC 
# X        Y1        Y2
x1       y1_1        y2_1
x2       y1_2        y2_2
... 
#+END_SRC
One case such as this would be having two different sensors for the
same property, which both took data at the same time. In those cases
one probably wants a plot of X against Y1 and X againt Y2 in one plot
with two different colors.

The naive way to do this is the following:
#+BEGIN_SRC nim :tangle recipes/rTwoSensorsBadStyle.nim
import ggplotnim, sequtils, seqmath
let df = toDf(readCsv("data/50-18004.CSV"))
ggplot(df) +
  geom_line(aes(x = "in_s", y = "C1_in_V", color = "C1")) +
  geom_line(aes(x = "in_s", y = "C2_in_V", color = "C2")) +
  ggsave("media/recipes/rTwoSensorsBadStyle.png")
#+END_SRC
This generates the following:

[[./media/recipes/rTwoSensorsBadStyle.png]]

Which means that we specify the =x= and =y= aesthetics only in the two
geoms and give it a color according to a string, which does represent
a column of the =df=. In that way the =color= is being /set/ to "C1"
and "C2". While this works it's maybe not the nicest way to handle
this, since the =gather= proc is specifically there to convert a table
from this short form of =X, Y1, Y2= to a long format dataframe of the
type =X, Key, Value=, where =Key= stores the name of the previous
column (or a custom name) and =Value= the value corresponding to =X=
of that column. This simplifies the plotting to a single call to
=geom_line= by specifying the =Channel= column as the discrete color scale:
#+BEGIN_SRC nim :tangle recipes/rTwoSensorsGoodStyle.nim
import ggplotnim, sequtils, seqmath
let df = toDf(readCsv("data/50-18004.CSV"))
let dfnew = df.gather(["C1_in_V", "C2_in_V"], key = "Channel", value = "V")
# Plotting via `df` directly causes scale problems!
ggplot(dfNew, aes("in_s", "V", color = "Channel")) +
  geom_line() +
  ggsave("media/recipes/rTwoSensorsGoodStyle.png")
#+END_SRC
Which then results in the following nicer plot (note that the legend
now says something more useful as its title):

[[./media/recipes/rTwoSensorsGoodStyle.png]]

*** Bar plot with many elements, rotate labels

When dealing with discrete data, which contains a large number of
labels a typical problem is that there's not enough space for all
labels. In this case we want to rotate the labels and right align
them. Considering some fake dataset with people who did some shifts
listed by year and we want a bar plot of the number of shifts each
person did per year. Also we need a much wider plot for this dataset:
#+BEGIN_SRC nim :tangle recipes/rBarPlotRotatedLabels.nim
import ggplotnim
let df = toDf(readCsv("data/fake_shifter_data.txt"))
ggplot(df, aes("Shifters", fill = "Year")) +
  geom_bar() +
  xlab(rotate = -45.0, margin = 1.75, alignTo = "right") +
  ggtitle("Number of shifts done by each shifter by year") +
  ggsave("media/recipes/rBarPlotRotatedLabels.png", width = 5000, height = 1000)
#+END_SRC
NOTE: It's recommended to generate a plot as this as a vector graphic
(svg, pdf) instead of a png. However, since these recipe plots are
part of the CI, we generate PNGs for all of them, since conversion
from svg, pdf yields bad results on travis.

Gives us the following plot. Probably better to look at the original
instead of the embedded plot, since it's so wide.

[[./media/expected/rBarPlotRotatedLabels.svg]]

*** Plot with custom annotation

Putting custom annotations onto the plot is supported. However the
styling of the annotations is still somewhat limited. 

Annotations can either be done via relative coordinates of the plot
area =(left, bottom)= or via data coordiantes =(x, y)=.

Note that the annotation is drawn *before* the data!

By default a white rectangular background is drawn behind the
annotation. This can be modified using the =backgroundColor= argument.

An example is shown below where we print the largest 5 values as an
annotation onto the plot.
#+BEGIN_SRC nim :tangle recipes/rCustomAnnotations.nim
import ggplotnim
import algorithm, sequtils, strformat, strutils
# get the data from one of the other recipes
let df = toDf(readCsv("data/50-18004.CSV"))
let dfnew = df.gather(["C1_in_V", "C2_in_V"], key = "Channel", value = "V")
# assume we want to create an annotation that prints the largest 5 values of
# Channel 2; get largest values, sorted by time (`in_s`)
let dfChMax = dfNew.filter(f{c"Channel" == "C2_in_V"})
  .arrange("V", SortOrder.Descending)
  .head(5)
  .arrange("in_s") # sort again by x axis
# build an annotation:
var annot: string
let idxs = toSeq({'A'..'E'})
for j, id in idxs:
  let xVal = alignLeft(formatFloat(dfChMax["in_s", j, float], precision = 2), 9)
  let yVal = formatFloat(dfChMax["V", j, float], precision = 4)
  annot.add &"{id}: (x: {xVal}, y: {yVal})"
  if j < idxs.high:
    annot.add "\n"
# create a font to use using the `ggplotnim.font` helper
let font = font(12.0, family = "monospace")
# now create the plot and put the annotation where we want it
ggplot(dfNew, aes("in_s", "V", color = "Channel")) +
  geom_line() +
  # either for instance in relative coordinates of the plot viewport
  # Values smaller 0.0 or larger 1.0 work too. Puts the annotation outside 
  # of the plot
  annotate(annot,
           left = 0.5,
           bottom = 1.0,
           font = font) +
  # or in data coordinates using `(x, y)`
  annotate(annot,
           x = -2e-6,
           y = 0.06,
           font = font,
           backgroundColor = parseHex("FFEBB7")) +
  ggsave("media/recipes/rCustomAnnotations.png")
#+END_SRC

Gives us this (somewhat ugly, but that's not the point) plot:
[[./media/recipes/rCustomAnnotations.png]]

*** Setting plot limits using =xlim=, =ylim=

It's also possible to limit / enlarge the plotting range using =xlim=
and =ylim=. The behavior of points which possibly lie outside the
plotting range is determined by the =outsideRange= argument, which can
take the values:
- "clip" (default): clip them to the maximum range of the limit
- "drop": drop those points from the plot
- "none": leave them as they are. Will potentially show them outside
  the plot area.
This becomes a little more complicated in combination with the
=xMargin= and =yMargin= procs. See below for an example.

First of all we can use it to enlarge the x range:
#+BEGIN_SRC nim :tangle recipes/rEnlargeXRange.nim
import ggplotnim
let df = toDf(readCsv("data/mpg.csv"))
ggplot(df, aes("hwy", "cty")) +
  geom_point() +
  xlim(10.0, 60.0) +
  ggsave("media/recipes/rEnlargeXRange.png")
#+END_SRC
which gives us:

[[./media/recipes/rEnlargeXRange.png]]

On the other hand we can also use it to limit the range of a plot:
#+BEGIN_SRC nim :tangle recipes/rLimitXRange.nim
import ggplotnim
let df = toDf(readCsv("data/mpg.csv"))
ggplot(df, aes("hwy", "cty")) +
  geom_point() +
  xlim(10.0, 30.0) +
  ggsave("media/recipes/rLimitXRange.png")
#+END_SRC

[[./media/recipes/rLimitXRange.png]]

Notice how all values larger than =30.0= (compare with plot above) are
being clipped to =30.0=. 

*** Creating a buffer zone with =xMargin= / =yMargin=

Sometimes it might be nice to have an explicit area in the plot, which
is used to designate data points, which lie outside a desired data
range (or are =Inf=). In this case the =xMargin= or =yMargin= procs
can be used (possibly in combination with =xlim=, =ylim= above).

Assuming we want to create the same plot as above, but for some reason
are only interested in y values up to =25=, but we want to be easily
aware all points, which are larger (but not equal!) that value. Let's
add margin in =y= to achieve that.

#+BEGIN_SRC nim :tangle recipes/rCreateMarginBuffer.nim
import ggplotnim
let df = toDf(readCsv("data/mpg.csv"))
ggplot(df, aes("hwy", "cty")) +
  geom_point() +
  ylim(5.0, 25.0) +
  yMargin(0.1) +
  ggsave("media/recipes/rCreateMarginBuffer.png")
#+END_SRC

[[./media/recipes/rCreateMarginBuffer.png]]

Notice how all values that are larger than =25= appear at the top of
the plot, while values smaller (and equal to 25) appear where they belong.

*** Highlight min / max of data in a plot

If we wish to highlight certain points of a plot with a specific geom
/ style we can do this in the following way. 

It is based on first filtering an additional dataset to the values to
be highlighted and then using the optional =color= etc. arguments to
the =geom_*= procs to set a certain style.

For instance let's highlight the min and max values of the second
channel from the [[Plotting column Y1 and Y2 against X]] example above.
#+BEGIN_SRC nim :tangle recipes/rHighlightMinMax.nim
import ggplotnim, algorithm
# base this on one of the above examples
let df = toDf(readCsv("data/50-18004.CSV"))
  .gather(["C1_in_V", "C2_in_V"], key = "Channel", value = "V")
# filter to Channel 2 and sort by voltage
let dfSorted = df.filter(f{c"Channel" == "C2_in_V"})
  .arrange("V", SortOrder.Descending)
# get min and max
let dfMax = dfSorted.head(1)
let dfMin = dfSorted.tail(1)
ggplot(df, aes("in_s", "V", color = "Channel")) +
  geom_line() + # the actual data
  # add additional geom with `data =` arg and set styles. 
  # NOTE: Style arguments use `Option[T]`!
  geom_point(data = dfMax,
             color = some(parseHex("FF0000")),
             size = some(10.0),
             marker = some(mkCross)) +
  geom_point(data = dfMin,
             color = some(parseHex("0000FF")),
             size = some(5.0)) +
  ggsave("media/recipes/rHighlightMinMax.png")
#+END_SRC

Results in the following plot:

[[./media/recipes/rHighlightMinMax.png]]

*** Applying a formula to an aesthetic

In some cases the data frame one has does not contain exactly the data
we actually want to plot. 

Take for instance the [[data/mpg.csv][mpg]] dataset where the fuel economoy is (as the
name implies) given in miler per gallon. People who use a sensible
unit system will probably want the fuel economy in liters per 100 km. 

There are two ways to plot =L/100km= instead of =mpg=. 

Either (as shown as an example in the [[https://github.io/vindaar/gglotnim][documentation]]) by mutating the
data frame we have using =transmute= or =mutate= to create a new,
transformed column.

The other way to achieve this is to provide a =FormulaNode= to the
=aes= call, like so:

#+BEGIN_SRC nim :tangle recipes/rFormulaAesthetic.nim
import ggplotnim
let df = toDf(readCsv("data/mpg.csv"))
ggplot(df, aes(f{235 / c"cty"}, "displ")) + 
  geom_point() +
  xlab("cty [L / 100km]") +
  ggsave("media/recipes/rFormulaAesthetic.png")
#+END_SRC

Which gives us:

[[media/recipes/rFormulaAesthetic.png]]

This approach can be used for (almost) arbitrary computations on (even
more than one) column. Note that if you wish to apply a =proc= to a
column, make sure it's lifted and corresponds to one of the types
explained in the [[README.org][README]].

*** Plotting error bars

Starting from version =v0.2.15= plotting of error bars is
supported. This is done via =geom_errorbar=.

Error bars are handled by new fields of the =Aesthetics= object,
namely =xMin=, =xMax=, =yMin= and =yMax=. The important thing to keep
in mind is that these fields require absolute values. So if you have
an error of =0.1= you don't set =yMin= to =-0.1= and =yMax= to =0.1=,
but rather you add and subtract from =y= using a formula. See the
example below. 

The example below assumes asymmetric, but constant errors of =0.03=
down and =0.05= up. Note that =xMin= etc. are completely normal
aesthetic fields. You can also assign a column of your DF with
precomputed min and max values or even use more complex functionality
provided by aesthetics via formulas, e.g. compute the square root
error via =yMax = f{`y` + sqrt(`y`)}= for instance.

#+BEGIN_SRC nim :tangle recipes/rErrorBar.nim
import ggplotnim, seqmath, sequtils
# create some polynomial data 
let x = linspace(0, 1.0, 10)
let y = x.mapIt(0.5 * it - 1.2 * it * it + 1.1 * it * it * it)
let df = seqsToDf(x, y)
# let's assume we have asymmetric errors, 0.03 down and 0.05 up
ggplot(df, aes("x", "y")) +
  geom_point() +
  # define errors as a formula, which references our "y" scale
  geom_errorbar(aes(yMin = f{`y` - 0.03}, yMax = f{`y` + 0.05})) +
  ggsave("media/recipes/rErrorBar.png")
#+END_SRC

Which results in the following plot:

[[media/recipes/rErrorBar.png]]

*** Plot with multiple legends

If a plot contains multiple aesthetic scales, which require a legend,
they will be attempted to be drawn above one another. 
However, at the time of version =v.0.2.18= they are not made smaller
so they fit. If too many elements are shown, they won't fit the plot.

An example below in which we classify by color and size:
#+BEGIN_SRC nim :tangle recipes/rMultipleLegends.nim
import ggplotnim
let df = toDf(readCsv("data/mpg.csv"))
ggplot(df, aes("cty", "displ", size = "cyl", color = "cty")) + #, color = "cty", size = "cyl")) +
  geom_point() +
  ggsave("media/recipes/rMultipleLegends.png")
#+END_SRC

*** Simple tile plot

For a simple tile plot, let's generate some data for a 28x28 tiling.

By default tiling will assume that the bin widhts of each tile is 1 in
each dimension. You can provide custom bin widths by using the 
- =width= 
- =height= 
aesthetic in the =aes= call. Same as with =geom_errorbar= this can
either be a full column containing widths for each tile or a constant
value via a formula, e.g. 
#+BEGIN_SRC nim
aes(x = ..., ..., width = f{0.95}, height = f{0.95})
#+END_SRC
to get tiles which only have a width of 0.95.

Also for tiles it may be (more so than other times) be desirable to
have each axis be considered discrete despite the data being
continuous like. In that case use =scale_*_continuous= as shown
(commented out) below.
#+BEGIN_SRC nim :tangle recipes/rSimpleTile.nim
import ggplotnim, random
var
  xs = newSeq[float]()
  ys = newSeq[float]()
  zs = newSeq[float]()
for x in 0 ..< 28:
  for y in 0 ..< 28:
    xs.add x.float
    ys.add y.float
    zs.add random(1.0)
let df = seqsToDf(xs, ys, zs)
ggplot(df, aes("xs", "ys", fill = "zs")) +
  geom_tile() +
  #scale_x_continuous(dcKind = dcDiscrete) +
  #scale_y_continuous(dcKind = dcDiscrete) +
  ggsave("media/recipes/rSimpleTile.png")
#+END_SRC

This gives us the following plot:

[[media/recipes/rSimpleTile.png]]

Note to get rid of the spacing on the upper and right side (or get
even spacing), use =xlim= and =ylim=.

*** Simple =geom_text= example

=geom_text= can be used to represent an additional scale on the plot
via text. E.g. either to write a classification as a string onto the
plot, overlay numbers onto points etc.

Take note that by default the text will be centered on the position
given by the =x= and =y= scales. You can change the alignment using
the =alignKind= argument to =geom_text= or by providing the optional
(in the sense of =Option[Font]=) =font= argument, which has an
=alignKind= field.

There are many ways it can be useful. However, =geom_text= is a
completely valid =geom=, which means we can replace e.g. a
=geom_point= by =geom_text= and the resulting plot works as expected
(although it may be messy):
#+BEGIN_SRC nim :tangle recipes/rSimpleGeomText.nim
import ggplotnim
let df = toDf(readCsv("data/mpg.csv"))
ggplot(df, aes("hwy", "displ")) + 
  geom_text(aes(text = "manufacturer")) + 
  ggsave("media/recipes/rSimpleGeomText.png")
#+END_SRC
This generates:

[[./media/recipes/rSimpleGeomText.png]]

*** Text can also be classified! colored and sized =geom_text=

We can take things even further by also applying additional scales to
the plot, which change the color and size of the shown text. That way
we can end up showing 5 different scales in a single plot! Again, the
following may not be the most reasonable example, but well...
#+BEGIN_SRC nim :tangle recipes/rClassifiedGeomText.nim
import ggplotnim
let df = toDf(readCsv("data/mpg.csv"))
ggplot(df, aes("hwy", "displ", color = "class", size = "cyl")) + 
  geom_text(aes(text = "manufacturer")) + 
  ggsave("media/recipes/rClassifiedGeomText.png")
#+END_SRC
This generates:

[[./media/recipes/rClassifiedGeomText.png]]

*** Annotating points using =geom_text=

In more practical terms we might want to annotate certain points with
text in a plot. This can also be done using =geom_text=. 

To avoid the text being drawn on top of the point, we can modify the =x=
or =y= scale of the aesthetic for =geom_text= to nudge it to the side.

Let's start from a simple combination of =geom_point= and =geom_text=:
#+BEGIN_SRC nim :tangle recipes/rAnnotateUsingGeomText.nim
import ggplotnim
let df = toDf(readCsv("data/mpg.csv"))
ggplot(df, aes("hwy", "displ")) + 
  geom_point() +
  geom_text(aes(x = f{c"hwy" + 0.3}, 
            text = "manufacturer"),
            alignKind = taLeft, 
            # font = some(font(10.0, ...)) <- you can also change the font
            ) + 
  ggsave("media/recipes/rAnnotateUsingGeomText.png")
#+END_SRC
This generates:

[[./media/recipes/rAnnotateUsingGeomText.png]]

This is still pretty messy and usually not what one might use
=geom_text= for. Instead let's consider a similar example where we
want to annotate the car model with the best fuel economy:
#+BEGIN_SRC nim :tangle recipes/rAnnotateMaxValues.nim
import ggplotnim 
let df = toDf(readCsv("data/mpg.csv"))
let dfMax = df.mutate(f{"mpgMean" ~ (`cty` + `hwy`) / 2.0})
  .arrange("mpgMean")
  .tail(1)
ggplot(df, aes("hwy", "displ")) + 
  geom_point(aes(color = "cty")) + # set point specific color mapping
  # Add the annotation for the car model below the point
  geom_text(data = dfMax,
            aes = aes(y = f{c"displ" - 0.2}, 
                      text = "model")) +
  # and add another annotation of the mean mpg above the point
  geom_text(data = dfMax,
            aes = aes(y = f{c"displ" + 0.2}, 
                      text = "mpgMean")) +
  ggsave("media/recipes/rAnnotateMaxValues.png")
#+END_SRC
This generates:

[[./media/recipes/rAnnotateMaxValues.png]]

*** Annotated heat map

=geom_text= and =geom_tile= can be nicely combined to create annotated
heatmaps.

Let's calculate the mean of highway fuel economy for each pair of
=(car class, number of cylinder)= in the =mpg= dataset and create an
annotated heatmap from the combination.
#+BEGIN_SRC nim :tangle recipes/rAnnotatedHeatmap.nim
import ggplotnim, random, math

let df = toDf(readCsv("data/mpg.csv"))
let dfRed = df.group_by(["class", "cyl"]).summarize(f{float: "meanHwy" << mean( c"hwy" )})
# stringification of formula is default name
let meanHwyCol = "meanHwy"
ggplot(dfRed, aes("class", "cyl", fill = meanHwyCol)) +
  geom_tile() +
  geom_text(aes(text = meanHwyCol)) +
  scale_y_continuous(dcKind = dcDiscrete) +
  ggsave("media/recipes/rAnnotatedHeatmap.png")
#+END_SRC

Which results in:
[[media/recipes/rAnnotatedHeatmap.png]]

*** Plot consisting of multiple subplots

In certain domains one often ends up with the desire to create a plot
from multiple subplots. This is supported already, but requires
explicit use of =ginger= functinoality at the moment.

See for an example, inspired by here:
https://staff.fnwi.uva.nl/r.vandenboomgaard/SP20162017/SystemsSignals/plottingsignals.html
below.

The major point is to create two plots (but not draw them) using
=ggcreate= with custom defined =width= and =height=. Then create a
viewport, which will hold the two plots, with width and height such
that the two plots fit. Then create a layout of rows / columns
(theoretically custom sizes can be set, but for an equal sized
subplot not required) and embed the plots.
#+BEGIN_SRC nim :tangle recipes/rMultiSubplots.nim
import ggplotnim, seqmath, math, sequtils, complex, ginger
let t = linspace(-0.02, 0.05, 1000)
let y1 = t.mapIt(exp(im(2'f64) * Pi * 50 * it).re)
let y2 = t.mapIt(exp(im(2'f64) * Pi * 50 * it).im)
let df = seqsToDf({ "t" : t,
                    "Re x(t)" : y1,
                    "Im x(t)" : y2 })
let plt1 = ggcreate(
  ggplot(df, aes("t", "Re x(t)")) + 
    geom_line() + 
    xlim(-0.02, 0.05) + 
    ggtitle("Real part of x(t)=e^{j 100 π t}"),
  width = 800, height = 300
)
let plt2 = ggcreate(
  ggplot(df, aes("t", "Im x(t)")) + 
    geom_line() + 
    xlim(-0.02, 0.05) + 
    ggtitle("Imaginary part of x(t)=e^{j 100 π t}"),
  width = 800, height = 300
)
# combine both into a single viewport to draw as one image
var plt = initViewport(wImg = 800, hImg = 600)#wImg = 800.0, hImg = 800)
plt.layout(1, rows = 2)
# embed the finished plots into the the new viewport
plt.embedAt(0, plt1.view)
plt.embedAt(1, plt2.view)
plt.draw("media/recipes/rMultiSubplots.png")
#+END_SRC

Which gives us:
[[media/recipes/rMultiSubplots.png]]

*** TODO Example of changing font size in plot

*** TODO Log(-log) plot

See TMAS section below for now.

*** TODO Line + point plot (w/ different) number of elements per type

See TMAS section below for now.

*** TODO Set custom margin on a label

*** TODO Add lines in a plot to highlight something

See TMAS section below for now.

*NOTE:* starting from version =v0.2.15=, this can also be achieved
using =geom_linerange=!



** TMAS "Tell Me A Story" recipes

This section goes for a more cohesive, explanatory and hopefully more
fun introduction to different kinds of plots. Also possible
alternatives might be discussed.

*** Fun with elements

WRITE ME

#+BEGIN_SRC nim :tangle recipes/rPeriodicTable.nim
import ggplotnim, sequtils, seqmath, strutils

##
## This is a straight up adaptation from the genius `plotnine` example
## here:
## https://plotnine.readthedocs.io/en/stable/generated/plotnine.geoms.geom_tile.html
##

var elements = toDf(readCsv("data/elements.csv"))
echo elements.pretty(5)

elements["group"] = elements["group"].toTensor(Value).map_inline(
  if x == %~ "-":
    %~ -1
  elif x.kind == VString:
    %~ parseInt(x.toStr)
  else:
    x)

# convert atomic mass floats to strings without explicit `"`
elements["atomic mass"] = elements["atomic mass"].toTensor(Value).map_inline(
  try:
    %~ parseFloat(pretty(x, emphStrNumber = false))
  except ValueError:
    x
)

var top = elements.filter(f{c"group" != -1})
var bottom = elements.filter(f{c"group" == -1})
top["x"] = top["group"]
top["y"] = top["period"]
echo top["x"]
echo top["y"]

const nrows = 2
const hshift = 3.5
const vshift = 3
bottom["x"] = toColumn cycle(arange(0, bottom.len div nrows), nrows).mapIt(it.float + hshift)
bottom["y"] = bottom["period"].toTensor(float).map_inline:
  x + vshift
echo bottom
const tile_width = 0.95
const tile_height = 0.95

# replace `elements` by stacked top and bottom
elements = bind_rows([top, bottom])

let splitDf = seqsToDf({
  "y": @[6, 7],
  "metal": @["lanthanoid", "actinoid"]
})

func cycle[T](s: openArray[T]; nums: seq[int]): seq[T] =
  result = newSeq[T](nums.foldl(a + b))
  var idx = 0
  for i in 0 ..< nums.len:
    for j in 0 ..< nums[i]:
      result[idx] = s[i]
      inc idx
# finally define rows and cols
let groupdf= seqsToDf({
    "group": arange(1, 19),
    "y": cycle(@[1, 2, 4, 2, 1], @[1, 1, 10, 5, 1])})
let periodDf = seqsToDf({
    "period": arange(1, 8),
    "x": cycle(@[0.5], @[7])})

ggplot(elements, aes("x", "y", fill = "metal")) +
  geom_tile(aes = aes(width = f{tileWidth},
                      height = f{tileHeight})) +
  geom_tile(data = splitDf,
            aes = aes(x = f{3 - tileWidth/4.0 + 0.25},
                      width = f{tileWidth / 2.0},
                      height = f{tileHeight})) +
  scale_y_continuous(dcKind = dcContinuous) +
  geom_text(aes(x = f{`x` + 0.15},
                y = f{`y` + 0.15},
                text="atomic number"),
            font = some(font(6.0))) +
  geom_text(aes(x = f{`x` + 0.5},
                y = f{`y` + 0.4},
                text="symbol"),
            font = some(font(9.0))) +
  geom_text(aes(x = f{`x` + 0.5},
                y = f{`y` + 0.6},
                text="name"),
            font = some(font(4.5))) +
  geom_text(aes(x = f{`x` + 0.5},
                y = f{`y` + 0.8},
                text="atomic mass"),
            font = some(font(4.5))) +
  geom_text(data = groupdf,
            aes = aes(x = f{`group` + 0.5},
                      y = f{`y` - 0.2},
                      text = "group"),
            font = some(font(9.0, color = color(0.5, 0.5, 0.5)))) +
  geom_text(data = periodDf,
            aes = aes(x = f{`x` + 0.3},
                      y = f{`period` + 0.5},
                      text = "period"),
            font = some(font(9.0, color = color(0.5, 0.5, 0.5)))) +
  legendPosition(0.82, 0.1) +
  theme_void() +
  scale_y_reverse() +
  scale_x_continuous(dcKind = dcContinuous) +
  ggsave("media/recipes/rPeriodicTable.png",
         width = 1000,
         height = 500)
#+END_SRC

which gives the following amazing result (better to look at a PDF!):
[[media/recipes/rPeriodicTable.png]]

*** Plot a function

Assuming we have some mathematical function we want to plot. While
this library is no =gnuplot=, this is still very simple (goes on
talking about not simple example...). Let's pretend we want to plot
the gravitational acceleration of a point mass according to
Newton. The analytical description would be

 [[./media/newton_eq.png]],

where =r= is the radial distance, =R= the radius of Earth, =m= the
mass of Earth and =G= the gravitational constant. It shows both the
case inside a massive body and outside.

Let's plot this for Earth in a range from Earth's center to X km!

First import the stuff we need:
#+BEGIN_SRC nim :tangle recipes/rNewtonAcceleration.nim
import ggplotnim
import seqmath # for linspace, pow
import sequtils # for mapIt
#+END_SRC 
Now we define the func, which returns the acceleration of Earth
depending on the radial distance =r=:
#+BEGIN_SRC nim :tangle recipes/rNewtonAcceleration.nim
func newtonAcceleration(r: float): float =
  ## returns the graviational acceleration experienced by a test mass
  ## at different distances from Earth (or inside Earth).
  ## `r` is the radial distance given in `m`
  const R = 6371 * 1000 # mean radius of Earth in m
  const m_E = 5.972e24 # kg
  const G = 6.674e-11 # m^3 kg^-1 s^-2
  if r < R:
    result = G * m_E * r / pow(R, 3.0)
  else:
    result = G * m_E / (r * r)
#+END_SRC
We have to define the range we actually want to look at. Let's
consider Earth's center up to roughly the geostationary orbit at
=~ 35,000 km=.
#+BEGIN_SRC nim :tangle recipes/rNewtonAcceleration.nim
let radii = linspace(0.0, 35_000_000, 1000) # up to geostationary orbit
# and the corresponding accelerations
let a = radii.mapIt(newtonAcceleration(it))
#+END_SRC
This gives us two =seq[float]=, but we need a =DataFrame=. So we
combine the two:
#+BEGIN_SRC nim :tangle recipes/rNewtonAcceleration.nim
var df = seqsToDf({ "r / m" : radii,
                    "g(r) / m s¯²" : a})
#+END_SRC
which gives us a data frame with two columns. The names are, as one can
guess, the given strings. (Note that in practice one might not want to
use unicode superscripts etc. It's just to show that it's possible and
allows us to have it in the y label without setting the y label
manually).

However, we might want to plot it against =km= instead of =m=, so
let's transmute the data frame:
#+BEGIN_SRC nim :tangle recipes/rNewtonAcceleration.nim
df = df.transmute(f{"r / km" ~ c"r / m" / 1000.0}, f{"g(r) / m s¯²"})
#+END_SRC
The =transmute= function takes a variable number of elements. Only
those columns that appear here (on the LHS of the ~) will be part of
the resulting data frame.

And finally create the plot of the dependency:
#+BEGIN_SRC nim :tangle recipes/rNewtonAcceleration.nim
ggplot(df, aes("r / km", "g(r) / m s¯²")) +
  geom_line() +
  ggtitle("Gravitational acceleration of Earth depending on radial distance") +
  ggsave("media/recipes/rNewtonAcceleration.png")
#+END_SRC
The resulting plot is the following:

[[./media/recipes/rNewtonAcceleration.png]]

and shows what we expect. A linear increase in acceleration up to the
surface and a =1/r^2= drop from there.
At this point we might ask "Do we recover the known 9.81 m/s^2 at the
surface?". Let's see. There's many different ways we could go on about
this. We'll use summarize:
#+BEGIN_SRC nim :tangle recipes/rNewtonAcceleration.nim
let maxG = df.summarize(f{float: "g_max" << max(c"g(r) / m s¯²")})
#+END_SRC

An alternative way would be to access the data column directly, like
so:
#+BEGIN_SRC nim :tangle recipes/rNewtonAcceleration.nim
let maxG_alt = df["g(r) / m s¯²"].toTensor(float).max
#+END_SRC
where access via =[]= returns a =PersistentVector[Value]=. To copy the values to a
=seq[Value]=, so that we can use procs like =max= on it, we can use
=vToSeq= (it's not just =toSeq=, because that breaks things:
https://github.com/nim-lang/Nim/issues/7322...)
Let's see what we have:
#+BEGIN_SRC nim :tangle recipes/rNewtonAcceleration.nim
echo "Max acceleration:\n ", maxG
#+END_SRC
which should give roughly =9.8 m / s^2=. The deviation comes from the fact
that we didn't actually look at the value at the surface exactly, but took a rough
grid from =0 - 35,000 km= with =1000= points. Evaluating the proc at the radius exactly
might give a better result:
#+BEGIN_SRC nim :tangle recipes/rNewtonAcceleration.nim
echo "At surface = ", newtonAcceleration(6371000)
#+END_SRC
except now we see a value slightly too large (=~ 9.82=). Because now
we'd have to include the rotation of Earth to account for the
centripetal force...  But since this isn't a physics lesson (going
down this rabbit hole is a lot of fun though, I promise!), we'll stop
here!

*** "Tell me an axion story without telling it to me" story

Creating a log-log plot is as easy as done in the =makePlot= proc at
the bottom. And yes, there'll be explanations soon here for the
curious of you! :)

#+BEGIN_SRC nim :tangle recipes/rAxionMassesLogLog.nim
import sequtils, seqmath, ggplotnim

proc effPhotonMass(ne: float): float =
  ## returns the effective photon mass for a given electron number density
  const alpha = 1.0 / 137.0
  const me = 511e3 # 511 keV
  # note the 1.97e-7 cubed to account for the length scale in `ne`
  result = sqrt( pow(1.97e-7, 3) * 4 * PI * alpha * ne / me )

proc numDensity(c: float): float =
  ## converts a molar concentration in mol / m^3 to a number density
  const Z = 2 # number of electron in helium atom
  result = Z * 6.022e23 * c

proc molarAmount(p, vol, temp: float): float =
  ## calculates the molar amount of gas given a certain pressure,
  ## volume and temperature
  ## the pressure is assumed in mbar
  const gasConstant = 8.314 # joule K^-1 mol^-1
  let pressure = p * 1e2 # pressure in Pa
  result = pressure * vol / (gasConstant * temp)

proc babyIaxoEffMass(p: float): float =
  ## calculates the effective photon (and thus axion mass) for BabyIAXO given
  ## a certain helium pressure in the BabyIAXO magnet
  const vol = 10.0 * (PI * pow(0.3, 2)) # 10m length, bore radius 30 cm
  # UPDATE: IAXO will be run at 4.2 K instead of 1.7 K
  # const temp = 1.7 # assume 1.7 K same as CAST
  const temp = 4.2
  once:
    echo "BabyIAXO magnet volume is ", vol, " m^3"
    echo "BabyIAXO magnet temperature is ", temp, " K"
  let amountMol = molarAmount(p, vol, temp) # amount of gas in mol
  let numPerMol = numDensity(amountMol / vol) # number of electrons per m^3
  result = effPhotonMass(numPerMol)

proc logspace(start, stop: float, num: int, base = 10.0): seq[float] =
  ## generates evenly spaced points between start and stop in log space
  let linear = linspace(start, stop, num)
  result = linear.mapIt(pow(base, it))

proc makePlot(pstart, pstop: float, fname: string) =
  let pressures = logspace(pstart, pstop, 1000) # 1000 values from 1e-5 mbar to 500 mbar
  let masses = pressures.mapIt(babyIaxoEffMass(it)) # corresponding masses
  # convert both seqs to a dataframe
  let df = seqsToDf({"P / mbar" : pressures, "m_a / eV" : masses})
  ggplot(df, aes("P / mbar", "m_a / eV")) +
    geom_line() +
    scale_x_log10() +
    scale_y_log10() +
    ggtitle("Sensitive axion mass in eV depending on helium pressure in mbar") +
    ggsave(fname)

makePlot(-6.0, 2.0, "media/recipes/rAxionMassesLogLog.png")
#+END_SRC

This creates the following plot:

[[./media/recipes/rAxionMassesLogLog.png]]

*** "Another one of the quiet stories" story 

A typical problem is comparing some measured data from experiment with
a theoretical model for which an analytical description may exist. So
that the analytical model may be represented by O(1000) elements,
while the measured data only consists of =N << 1000= elements. This
can be done as shown below. It creates a plot of the mass attenuation
function of X-rays in the energy range between =0-10 keV= (very soft
X-rays) for ⁴He.
#+BEGIN_SRC nim :tangle recipes/rMassAttenuationFunction.nim
import sequtils, seqmath, ggplotnim

proc logMassAttenuation(e: float): float =
  ## calculates the logarithm of the mass attenuation coefficient for a given
  ## energy `e` in `keV` and the result in `cm^2/g`
  result = -1.5832 + 5.9195 * exp(-0.353808 * e) + 4.03598 * exp(-0.970557 * e)

let energies = linspace(0.0, 10.0 , 1000) # from 0 to 10 keV
let logMuOverRho = energies.mapIt(logMassAttenuation(it))
# now the non-log values
let muOverRho = logMuOverRho.mapIt(exp(it))

const massAttenuationFile = "data/mass_attenuation_nist_data.txt"
# skip one line after header, second header line
var dfMuRhoTab = toDf(readCsv(massAttenuationFile, header = "#", 
                              skipLines = 1, sep = ' '))
  # convert MeV energy to keV
  .mutate(f{"Energy" ~ c"Energy" * 1000.0})
  .filter(f{float: c"Energy" >= energies.min and c"Energy" <= energies.max})
# create df of interpolated values
let dfMuRhoInterp = seqsToDf({ "E / keV" : energies,
                               "mu/rho" : muOverRho })
# rename the columns of the tabulated values df and create a log column
dfMuRhoTab = dfMuRhoTab.rename(f{"E / keV" <- "Energy"})
# build combined DF
let dfMuRho = bind_rows([("Interpolation", dfMuRhoInterp), 
                         ("NIST", dfMuRhoTab)], 
                        id = "type")

# and the plot of the raw mu/rho values
ggplot(dfMuRho, aes("E / keV", "mu/rho", color = "type")) + 
  geom_line(data = dfMuRho.filter(f{`type` == "Interpolation"})) +
  geom_point(data = dfMuRho.filter(f{`type` == "NIST"})) +
  scale_y_log10() +
  ggtitle("Mass attenuation coefficient interpolation and data") +
  ggsave("media/recipes/rMassAttenuationFunction.png")
#+END_SRC

Gives:

[[./media/recipes/rMassAttenuationFunction.png]]

*** TODO Add lines in a plot to highlight something

See TMAS section below for now.

#+BEGIN_SRC nim :tangle recipes/rAxionMassVsDensity.nim
import sequtils, seqmath, ggplotnim

proc logspace(start, stop: float, num: int, base = 10.0): seq[float] =
  ## generates evenly spaced points between start and stop in log space
  let linear = linspace(start, stop, num)
  result = linear.mapIt(pow(base, it))

proc density(p: float, temp = 4.2): float = 
  ## returns the density of the gas for the given pressure.
  ## The pressure is assumed in `mbar` and the temperature (in `K`).
  ## The default temperature corresponds to BabyIAXO aim.
  ## Returns the density in `g / cm^3`
  const gasConstant = 8.314 # joule K^-1 mol^-1
  const M = 4.002602 # g / mol
  let pressure = p * 1e2 # pressure in Pa
  # factor 1000 for conversion of M in g / mol to kg / mol
  result = pressure * M / (gasConstant * temp * 1000.0)
  # convert the result to g / cm^3 for use with mass attenuations
  result = result / 1000.0

proc numDensity(c: float): float =
  ## converts a molar concentration in mol / m^3 to a number density
  const Z = 2 # number of electron in helium atom
  result = Z * 6.022e23 * c

proc effPhotonMass(ne: float): float =
  ## returns the effective photon mass for a given electron number density
  const alpha = 1.0 / 137.0
  const me = 511e3 # 511 keV
  # note the 1.97e-7 cubed to account for the length scale in `ne`
  result = sqrt( pow(1.97e-7, 3) * 4 * PI * alpha * ne / me )

proc pressureGivenEffPhotonMass(m_gamma: float, T = 4.2): float =
  ## calculates the inverse of `babyIaxoEffPhotonMass`, i.e. the pressure 
  ## from a given effective photon mass in BabyIAXO
  result = m_gamma * m_gamma * T / 0.01988

proc molarAmount(p, vol, temp: float): float =
  ## calculates the molar amount of gas given a certain pressure,
  ## volume and temperature
  ## the pressure is assumed in mbar
  const gasConstant = 8.314 # joule K^-1 mol^-1
  let pressure = p * 1e2 # pressure in Pa
  result = pressure * vol / (gasConstant * temp)

proc babyIaxoEffMass(p: float): float =
  ## calculates the effective photon (and thus axion mass) for BabyIAXO given 
  ## a certain helium pressure in the BabyIAXO magnet
  const vol = 10.0 * (PI * pow(0.3, 2)) # 10m length, bore radius 30 cm 
  const temp = 4.2
  let amountMol = molarAmount(p, vol, temp) # amount of gas in mol
  let numPerMol = numDensity(amountMol / vol) # number of electrons per m^3
  result = effPhotonMass(numPerMol) 

proc vacuumMassLimit(energy: float, magnetLength = 10.0): float =
  ## given an axion energy in keV, calculate the limit of coherence
  ## for the vacuum case in BabyIAXO
  let babyIaxoLen = magnetLength / 1.97e-7 # length in "eV"
  result = sqrt(PI * 2 * energy * 1e3 / babyIaxoLen) # convert energy to eV

const babyIaxoVacuumMassLimit = vacuumMassLimit(4.2)
proc m_a_vs_density(pstart, pstop: float) =
  let pressures = logspace(pstart.log10, pstop.log10, 1000)
  let densities = pressures.mapIt(density(it, 4.2))
  let masses = pressures.mapIt(babyIaxoEffMass(it)) # corresponding masses
  # convert both seqs to a dataframe
  let ref1Bar = density(1000, 293.15)
  let df1bar = seqsToDf({"ρ / g/cm^3" : @[ref1Bar, ref1Bar], "m_a / eV" : @[1e-2, 1.0]})
  let ref3Bar = density(3000, 293.15)
  let df3bar = seqsToDf({"ρ / g/cm^3" : @[ref3Bar, ref3Bar], "m_a / eV" : @[1e-2, 1.0]})
  let refVacLimit = density(pressureGivenEffPhotonMass(babyIaxoVacuumMassLimit))
  let dfVacLimit = seqsToDf({"ρ / g/cm^3" : @[refVacLimit, refVacLimit], "m_a / eV" : @[1e-2, 1.0]})
  let df = seqsToDf({"ρ / g/cm^3" : densities, "m_a / eV" : masses})
  let dfComb = bind_rows([("ma vs ρ", df),
                          ("1 bar @ 293 K", df1bar),
                          ("3 bar @ 293 K", df3bar),
                          ("Vacuum limit", dfVacLimit)],
                         id = "Legend")
  ggplot(dfComb, aes("ρ / g/cm^3", "m_a / eV", color = "Legend")) +
    geom_line() + 
    scale_x_log10() + 
    scale_y_log10() +
    ggtitle("Sensitive axion mass in eV depending on helium density in g / cm^3") +
    ggsave("media/recipes/rAxionMassVsDensity.png")

m_a_vs_density(pressureGivenEffPhotonMass(babyIaxoVacuumMassLimit) * 0.9,
               pressureGivenEffPhotonMass(0.4521) * 1.1)
#+END_SRC

Which gives us the following annotated plot:

[[./media/recipes/rAxionMassVsDensity.png]]

** Other resources


*** BabyIAXO calculations
While the following document was mainly written for myself, it might
be a nice example as to how one might use =ggplotnim= to explore some
calculation, generate a bunch of plots in a literate environment
(almost relieving us of our desire for a [[https://github.com/Vindaar/brokenRepl][working repl...]]) etc. It
showcases a variety of plots one might want to create. At some point
those will be part of the recipes above... In fact the plots found in
the document below correspond to the TODO items in the GTTP section.

It contains calculations (and a lot of plots) for the sensitive axion
mass ranges achievable in the BabyIAXO experiment, a prototype for the
[[http://iaxo.web.cern.ch/][IAXO]] experiment.
- the original Org file (do yourself a favor and view it in emacs):
  https://github.com/Vindaar/TimepixAnalysis/blob/refactorRawManipulation/Doc/other/axionWithGasPhase.org
- the generated PDF:
  https://github.com/Vindaar/TimepixAnalysis/blob/refactorRawManipulation/Doc/other/axionWithGasPhase.pdf


